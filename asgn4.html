<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link href="style.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>Harlan Williams's Page</title>
</head>
<body>
  <header>
    <h1>EECS 348 Labs</h1>
    <ul>
      <li><a href="index.html">Index</a></li>
      <li><a href="lab1.html">Lab 1&mdash;Git and GitHub</a></li>
      <li><a href="lab2.html">Lab 2&mdash;Regular expressions</a></li>
      <li><a href="lab3.html">Lab 3&mdash;Makefiles</a></li>
      <li><a href="lab4.html">Lab 4&mdash;Web programming</a></li>
      <li><a href="lab5.html">Lab 5&mdash;UML use cases</a></li>
      <li><a href="lab6.html">Lab 6&mdash;UML class diagrams</a></li>
      <li><a href="lab7.html">Lab 7&mdash;C programming</a></li>
      <li><a href="asgn4.html">Assignment 4</a></li>
      <li><a href="lab8.html">Lab 8&mdash;C++ programming</a></li>
    </ul>
  </header>
  <main>
    <h1>Assignment 4</h1>
    <h2>Introduction</h2>
    <p>
      The goal of this project was to reimplement assignment 1 in C.
    </p>
    <h3>Major implementation differences</h3>
    <p>
      The biggest difference between this implementation and the Python implementation
      is the introduction of manual memory management. We have to think more carefully
      about how we store and access memory in this program, not only for our emails but
      also for the character strings in the emails and for any data structures we define.
      The tools C gives us for this are pointers and functions for allocating and freeing
      memory.
    </p>
    <h4>Pointers</h4>
    <p>
      All variables have types in C. These can be either a base type (<code>int</code>, <code>char</code>, <code>float</code>, <em>etc.</em>),
      the type of a user-defined struct, or a pointer to a type, including a pointer to a pointer.
      The type of a variable defines the kind of data it can store. A variable of type <code>int</code> can only hold an integer value between <code>-2^31</code> and <code>2^31-1</code>, while
      a variable of type <code>char</code> can only hold an 8-bit value corresponding to an <a href="https://www.ascii-code.com/">ASCII code</a>.
      We can turn a type into a pointer for that type by prefixing the variable name with an asterisk (<code>*</code>).
      For example, <code>int *x</code> makes <code>x</code> a pointer to an integer.
    </p>
    <p>
      The difference between a variable of base type and a variable of pointer type is whether the variable holds a <em>value</em> or if it holds a <em>memory address</em>.
      Values are stored at specific memory addresses and modifying a value modifies the contents of that memory address.
      A pointer allows us to have a single variable that interacts with different memory addresses.
    </p>
    <pre>
      int x = 5;  // 4 bytes, stored at memory address 0x0000
      int y = 10; // 4 bytes, stored at memory address 0x0004
      int z = 15; // 4 bytes, stored at memory address 0x0008
      
      int *ptr = &amp;x; // `ptr` gets the memory address of `x`: 0x0000
      *ptr // this gets the value stored at the memory address 0x0000
      ptr = &amp;y // set `ptr` to the memory address of `y`: 0x0004
      *ptr // dereferencing now gives what is in address 0x0004: the value of `y`
    </pre>
    <h4>Allocating and freeing memory</h4>
    <p>
      We have the tools to make pointers to single objects, but not to arrays of objects such as what we need to hold lists of emails.
      The <code>malloc</code> function gives us a pointer to a memory area that can hold multiple objects.
      To use it, we pass in how many bytes long we want our memory area, and it gives us back a pointer to that area.
      We can then access objects in that memory by array offsets. Its usage goes like:
    </p>
    <pre><code class="language-c">/* create a memory area big enough to hold 8 integers */
int *x = malloc(sizeof(int) * 8);
x[0] = 1;
x[1] = 2;
x[2] = 3;
/* ... */</code></pre>
    <p>
      We calculate the size of the base type multiplied by how many slots of that type we want the array to be able to hold.
      And when we are done using that memory, we need to use <code>free</code> to de-allocate it.
      When we call <code>malloc</code>, the operating system sets aside that many bytes of memory for our program.
      It has no base variable that refers to it, only a pointer, so if we lose the pointer, that memory area still exists but is inaccessible.
    </p>
    <pre><code class="language-c">free(x);</code></pre>
    <p>
      We can find the size of the base type by using <code>sizeof *x</code> rather than <code>sizeof(int)</code>.
      Because <code>x</code> is a pointer to an <code>int</code>, dereferencing gives an <code>int</code>, so we can find the size of the type <code>x</code> points to
      by dereferencing it. This operation doesn't actually use the value at <code>x</code>'s memory address, so it doesn't matter if it is initialized or not.
    </p>
    <p>
      The last memory function used in this code is <code>realloc</code>, which takes a pre-existing memory area allocated with <code>malloc</code> and moves all of its
      contents into a new memory area of a different size and frees the original memory. This is how we can replicate the behavior of a Python list that grows and shrinks
      as needed with C arrays which always have a fixed size.
    </p>
    <h3>Structure of this document</h3>
    <p>
      This document is written in a way that all of the code can be copy-pasted into various files and compiled
      with some modifications: namely the preprocessor directives (<code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>)
      and function signatures will need to be added to the header files. There are also minimal
      comments in the code itself as all of the documentation behind the code and the
      design choices that were made are on this page. Any comments that do exist are
      for explaining specific C syntax rather than for explaining intent or behavior.
    </p>
    <p>
      There is also no <code>Makefile</code> provided, but the project structure should be
      simple enough that the one from <a href="lab3.html">lab 3</a> can be modified to
      compile it.
    </p>
    <h2>Implementation</h2>
    <h3>Dynamic array</h3>
    <p>
      The Python implementation of this assignment had a list that could
      expand and shrink as needed, so the first data structure implemented
      here was a dynamic array in order to capture that behavior. In
      C, we can have pointers to either single objects or to <em>arrays</em> of objects.
      The only catch is these arrays have a static size, so they cannot
      grow if we want to put more objects in them than their initial size
      holds. To get around this, we implement a data structure that starts
      with an initial number of empty <code>slots</code>, and we add objects
      into those slots as needed until we exceed the number of available
      slots. When this happens, we re-allocate our array to have more
      empty slots and then continue as usual.
    </p>
    <p>
      The default number of slots is defined in <code>ARR_DEFAULT_SLOTS</code>. Whenever we need to
      expand the array, we multiply the number of array slots by <code>ARR_GROW_BY</code> and use
      <code>realloc</code> to get a new array of that size. To keep track of the number of slots,
      number of elements, and the memory address of the array, we create a <code>EmailArray</code> struct which holds both the total number of
      <code>slot</code>s, filled or empty, and the number of objects in the array in <code>length</code>.
      Because the only data structure this array will be holding is an <code>Email</code>, the array holds
      a pointer to <code>Email</code>, which is what will point to our dynamically resized array.
    </p>
    <pre><code class="language-c">/* array.h */

#define ARR_DEFAULT_SLOTS 8
#define ARR_GROW_BY 2
#define ARR_SHRINK_BY 2

typedef struct _EmailArray {
    Email *emails;
    size_t length;
    size_t slots;
} EmailArray;</code></pre>
    <p>
      To allocate the array, we use <code>malloc</code> which requires the number of bytes to allocate. To calculate
      this, I can find the number of bytes one <code>Email</code> takes up with <code>sizeof Email</code>.
      It's better practice however to use <code>sizeof *array-&gt;emails</code>, in case the type of <code>array-&gt;emails</code>
      may ever need to change. The calculation is the same because we find the size of the contents of what <code>array-&gt;emails</code>
      points to. We then multiply by the number of slots in our array, so in sum we calculate: bytes in one Email * Email slots in our array.
    </p>
    <p>
      When we add an <code>Email</code> to our <code>Array</code>, we have to check if there's an empty slot for it or not.
      If there is not, we grow the number of slots by multiplying by <code>ARR_GROW_BY</code> and then calling <code>realloc</code>,
      calculating the number of bytes in the new array in exactly the same way as before. Here we pass a pointer to the
      original array as well, so that <code>realloc</code> can automatically copy over the memory of our original array to the new one
      and free the old one.
    </p>
    <pre><code class="language-c">/* array.c */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "email.h"
#include "array.h"

static void grow_array(EmailArray *array, int factor) {
    array-&gt;slots *= factor;
    array-&gt;emails = realloc(array-&gt;emails, array-&gt;slots * sizeof *array-&gt;emails);
}

static void shrink_array(EmailArray *array, int factor) {
    if (array.slots > ARR_DEFAULT_SLOTS) {
        array-&gt;slots /= factor;
        array-&gt;emails = realloc(array-&gt;emails, array-&gt;slots * sizeof *array-&gt;emails);
    }
}

void new_array(EmailArray *array) {
    array-&gt;length = 0;
    array-&gt;slots = ARR_DEFAULT_SLOTS;
    array-&gt;emails = malloc(array-&gt;slots * sizeof *array-&gt;emails);
}

void append_email(EmailArray *array, Email *email) {
    if (array-&gt;slots == array-&gt;length) {
        grow_array(array, ARR_GROW_BY);
    }

    array-&gt;emails[array-&gt;length] = *email;
    array-&gt;length += 1;
}

void pop_email(EmailArray *array, Email *email) {
    if (array-&gt;length == 0) {
        return;
    }

    array-&gt;length -= 1;

    if (email) {
        *email = array-&gt;emails[array-&gt;length];
    }

    if (4*array-&gt;length &lt;= array-&gt;slots) {
        shrink_array(array, ARR_SHRINK_BY);
    }
}

void free_array(EmailArray *array) {
    free(array-&gt;emails);
    array-&gt;emails = NULL;
    array-&gt;length = 0;
    array-&gt;slots = 0;
}</code></pre>
    <h3>Heap</h3>
    <p>
      Now that we have a dynamic array, we can build a heap on top of it. Many of the functions
      below are exactly the same as in Python now, except for the need to allocate and
      free the heap manually.
    </p>
    <pre><code class="language-c">/* heap.h */

typedef struct _Heap {
    EmailArray array;
} Heap;</code></pre>
    <p>
      I create a new structure named <code>Heap</code> that simply wraps an <code>Array</code>. This
      is because I treat it differently than a normal <code>Array</code> and have a different set of
      functions I want to call on it.
    </p>
    <pre><code class="language-c">/* heap.c */

#include &lt;stdlib.h&gt;

#include "array.h"
#include "heap.h"

/* these functions are static because they are called only
 * within this file, and not made available in the header */

static size_t parent(size_t idx) {
    return idx == 0 ? 0 : (idx - 1) / 2;
}

static size_t left_child(size_t idx) {
    return 2*idx + 1;
}

static size_t right_child(size_t idx) {
    return 2*idx + 2;
}

/* `restrict` tells the compiler that these pointers will never
 * be pointing to the same object */
static void swap(Email *restrict e1, Email *restrict e2) {
    Email tmp = *e1;
    *e1 = *e2;
    *e2 = tmp;
}

static void bubble_down(Heap *heap, size_t idx) {
    if (idx &gt; heap-&gt;array.length) {
        return;
    }

    Email *e1 = &amp;heap-&gt;array.emails[idx];

    if (left_child(idx) &lt; heap-&gt;array.length) {
        Email *e2 = &amp;heap-&gt;array.emails[left_child(idx)];
        if (cmp_priority(e1, e2) == -1) {
            swap(e1, e2);
            bubble_down(heap, left_child(idx));
        }
    }

    if (right_child(idx) &lt; heap-&gt;array.length) {
        Email *e3 = &amp;heap-&gt;array.emails[right_child(idx)];
        if (cmp_priority(e1, e3) == -1) {
            swap(e1, e3);
            bubble_down(heap, right_child(idx));
        }
    }
}

static void bubble_up(Heap *heap, size_t idx) {
    if (idx == 0) {
        return;
    }

    Email *e1 = &amp;heap-&gt;array.emails[idx];
    Email *e2 = &amp;heap-&gt;array.emails[parent(idx)];
    if (cmp_priority(e1, e2) == 1) {
        swap(e1, e2);
        bubble_up(heap, parent(idx));
    }
}

void new_heap(Heap *heap) {
    new_array(&amp;heap-&gt;array);
}

void insert_heap(Heap *heap, Email *email) {
    append_email(&amp;heap-&gt;array, email);
    bubble_up(heap, heap-&gt;array.length - 1);
}

void pop_heap(Heap *heap, Email *email) {
    swap(&amp;heap-&gt;array.emails[0], &amp;heap-&gt;array.emails[heap-&gt;array.length - 1]);
    pop_email(&amp;heap-&gt;array, email);
    bubble_down(heap, 0);
}

void free_heap(Heap *heap) {
    free_array(&amp;heap-&gt;array);
}</code></pre>
    <h3>Email</h3>
    <pre><code class="language-c">/* email.h */
        
typedef struct _Email {
    char subject[32];
    char sender[32];
    Date date;
    int priority;
} Email;</code></pre>
    <pre><code class="language-c">/* email.c */

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "date.h"
#include "email.h"

Email new_email(char *subject, char *sender, Date date, int priority) {
    Email e;
    strncpy(e.subject, subject, sizeof e.subject);
    strncpy(e.sender, sender, sizeof e.sender);
    e.date = date;
    e.priority = priority;

    return e;
}

/* `restrict` tells the compiler that these pointers will never
 * be pointing to the same object */
int cmp_priority(Email *restrict e1, Email *restrict e2) {
    if (e1-&gt;priority &gt; e2-&gt;priority) {
        return 1;
    } else if (e1-&gt;priority &lt; e2-&gt;priority) {
        return -1;
    } else {
        return cmp_dates(e1-&gt;date, e2-&gt;date);
    }
}

Email email_from_string(char *string) {
    Email e;
    memset(e.sender, 0, sizeof e.sender);
    memset(e.subject, 0, sizeof e.subject);

    char *sender = strtok(string, ",");
    strncpy(e.sender, sender, sizeof e.sender);
    char *subject = strtok(NULL, ",");
    strncpy(e.subject, subject, sizeof e.subject);
    char *date = strtok(NULL, ",");
    e.date = date_from_string(date);

    if (strcmp("Boss", e.sender) == 0) {
        e.priority = 5;
    } else if (strcmp("Subordinate", e.sender) == 0) {
        e.priority = 4;
    } else if (strcmp("Peer", e.sender) == 0) {
        e.priority = 3;
    } else if (strcmp("ImportantPerson", e.sender) == 0) {
        e.priority = 2;
    } else {
        e.priority = 1;
    }

    return e;
}</code></pre>
    <h3>Date</h3>
    <pre><code class="language-c">/* date.h */
        
typedef struct _Date {
    int year;
    int month;
    int day;
} Date;</code></pre>
    <pre><code class="language-c">/* date.c */
        
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "date.h"

int cmp_dates(Date d1, Date d2) {
    if (d1.year &gt; d2.year) {
        return 1;
    } else if (d1.year &lt; d2.year) {
        return -1;
    }
    if (d1.month &gt; d2.month) {
        return 1;
    } else if (d1.month &lt; d2.month) {
        return -1;
    }
    if (d1.day &gt; d2.day) {
        return 1;
    } else if (d1.day &lt; d2.day) {
        return -1;
    }
    return 0;
}

Date date_from_string(char *string) {
    Date d;

    char *month = strtok(string, "-");
    d.month = atoi(month);
    char *day = strtok(NULL, "-");
    d.day = atoi(day);
    char *year = strtok(NULL, "-");
    d.year = atoi(year);

    return d;
}</code></pre>
  </main>
</body>
</html>

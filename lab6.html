<!DOCTYPE html>
<html lang="en-US">
<head>
  <title>Harlan Williams's Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link href="style.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>
<body>
  <header>
    <h1>EECS 348 Labs</h1>
    <ul>
      <li><a href="index.html">Index</a></li>
      <li><a href="lab1.html">Lab 1&mdash;Git and GitHub</a></li>
      <li><a href="lab2.html">Lab 2&mdash;Regular expressions</a></li>
      <li><a href="lab3.html">Lab 3&mdash;Makefiles</a></li>
      <li><a href="lab4.html">Lab 4&mdash;Web programming</a></li>
      <li><a href="lab5.html">Lab 5&mdash;UML use cases</a></li>
      <li><a href="lab6.html">Lab 6&mdash;UML class diagrams</a></li>
    </ul>
  </header>
  <main>
    <h1>Lab 6 &mdash; UML class diagrams</h1>
    <p>
      <a href="slides/lab6.pdf">Slides</a>. Creating UML class diagrams to show the structure of an object-oriented program. Some advice for Assignment 4.
    </p>
    <h2>Assignment 4</h2>
    <p>
      The following should hopefully help get you started with assignment 4 by explaining how to do some more complicated things in C.
    </p>
    <h3>Reading strings</h3>
    <p>
      To read input from a file in C, we can use the <code>fread</code> function. By the way, for all of the functions mentioned here, if you are on Linux or macOS
      you can type the command <code>man &lt;function&gt;</code> into your terminal to get a help page about that specific function. We can grab the first line of
      our input with the following code:
    </p>
      <pre>
        <code class="language-c">char buffer[512];
FILE *fp = fopen("input.txt", "r"); /* "r" here means: open the file in read mode */

char *line = fgets(buffer, sizeof buffer, fp); /* fgets will read up to the first newline or
                                                * the end of the file, whichever comes first */</code>
      </pre>
    <p>
      Here we allocate an array of characters for the text to be read into, named creatively <code>buffer</code>. We make it 512 characters long, which should be
      sufficient for the input files you'll be working with. Next we open <code>input.txt</code> by calling <code>fopen</code>, which returns a pointer to the
      file handle. So far, this is exactly equivalent to <code>with open("input.txt", "r") as file:</code> in Python. The last line in this block reads a line
      from the input file and stores it in the character pointer <code>line</code>. The <code>fgets</code> function takes as arguments: our buffer, its length that we get
      with the keyword <code>sizeof</code>, and the file handle pointer <code>fp</code> at the end.
    </p>
    <p>
      This just grabs the first line for us, and we want to be able to read the entire input file. We can do this by calling <code>fgets</code> in a loop until it
      returns <code>NULL</code>, which means it has ran into the end of the file.
    </p>
    <pre>
      <code class="language-c">char buffer[512];
FILE *fp = fopen(filename, "r");
char *line = fgets(buffer, sizeof buffer, fp);

while (line != NULL) { /* make sure there even is another line */
    process_line(line);
    line = fgets(buffer, sizeof buffer, fp) /* get the next input line */
}</code>
    </pre>
    <p>
      Here we use a while-loop to continuously grab lines and pass them to the function <code>process_input</code>. For instance, if process_input
      just called <code>printf</code> on the line, this code would print the input file out to the terminal. This should be enough to read the input, just keep
      in mind that each line will have a newline character at the end.
    </p>
    <h3>Parsing strings</h3>
    <p>
      In Python, if you are given a string of comma-delimited values, you can simply call <code class="language-python">string.split(",")</code> to get
      a list of those values. In C, an equivalent is the function <code class="language-c">strtok</code>. Its usage is a bit odd to get used to at first.
      If we have the string <code>"Peer,Can you help me on this?,12-01-2024"</code> from the input file, we want to split it up by comma.
      To do this with <code class="language-c">strtok</code>, we do:
    </p>
    <pre>
      <code class="language-c">/* Small technicality: strtok can't modify a constant string, so we create a new string with strdup.
 * In your own code, this won't be an issue because you won't be hard-coding the input, right? */
const char *line = "Peer,Can you help me on this?,12-01-2024";
char *input = strdup(line);

char *sender = strtok(input, ",");
char *subject = strtok(NULL, ",");
char *date = strtok(NULL, ",");</code>
    </pre>
    <p>
      The first call takes the input string and the delimiter, the <code>","</code>, and returns the part of the string up to the first instance of the delimiter
      character. What is really going on is: In C, a string is just an array of characters of any length. To know when a string ends, there is always a <code>'\0'</code>
      character at the end of the array, and every string processing function in C knows to stop when it hits this character. So <code>strtok</code> looks for the
      first instance of the delimiter it sees, replaces it with a <code>'\0'</code>, and returns a pointer to the start of the string.
    </p>
    <p>
      The second call to <code>strtok</code> takes <code>NULL</code> rather than the input string again, because the function saves its location in the string. Otherwise
      it would start at the beginning again, but this time find the <code>'\0'</code> character that it replaced before and stop, which returns nothing. So the second line
      starts after the character it replaced, and does the same thing, replacing the second comma with a <code>'\0'</code> and returning a pointer to the string after the
      first comma.
    </p>
    <p>
      When <code>strtok</code> is finished, it will return <code>NULL</code>, or it may also return <code>NULL</code> if there are any errors in its input, so it is important to check that
      it is returning strings when you expect strings, and <code>NULL</code> when you expect it to be done. So after the lines above, you could put:
    </p>
    <pre>
    <code class="language-c">if (sender == NULL || subject == NULL || date == NULL) {
    printf("[Error] One of the parsed strings is NULL\n");
}

if (strtok(NULL, ",") != NULL) {
    printf("[Error] Expected strtok to return NULL when finished processing input\n");
}</code>
    </pre>
  </main>
</body>
</html>